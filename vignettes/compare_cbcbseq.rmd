# Testing my code vs. cbcbSEQ

## Load data

This will use the pasilla dataset exactly as cbcbSEQ did.

```{r load_tools}

library(hpgltools)
autoloads_all()
require.auto("pasilla")

```

```{r load_data}

## locate the path of the dataset and read in the dataset
datafile = system.file("extdata/pasilla_gene_counts.tsv", package="pasilla")
counts = read.table(datafile, header=TRUE, row.names=1)
head(counts)
dim(counts)
counts = counts[rowSums(counts) > ncol(counts),]
dim(counts)
design = data.frame(row.names=colnames(counts), 
    condition=c("untreated","untreated","untreated",
        "untreated","treated","treated","treated"),
    libType=c("single-end","single-end","paired-end",
        "paired-end","single-end","paired-end","paired-end"))
design

```

## Load data into hpgltools

```{r hpgltools_load}

metadata = design
colnames(metadata) = c("condition","batch")
metadata$Sample.id = rownames(metadata)
pasilla_expt = create_expt(count_dataframe=counts, meta_dataframe=metadata)

```

## Test starting data

```{r cbcb_hpgl_data}

cbcb_data = counts
hpgl_data = exprs(pasilla_expt$expressionset)
all.equal(cbcb_data, hpgl_data)

```

## Test quantile normalization

## cbcbSEQ result

Start out by testing the results of quantile normalization.
If diff_df() returns a bunch of 1's, then the columns of the data sets are exactly the same.

```{r cbcbSEQ_result}

cbcb_quantile = cbcbSEQ::qNorm(counts)
hpgl_quantile_data = hpgl_norm(expt=pasilla_expt, transform="raw", norm="quant", convert="raw", filter_low=FALSE)
hpgl_quantile = hpgl_quantile_data$counts
all.equal(cbcb_quantile, hpgl_quantile)

quantile_expt = normalize_expt(expt=pasilla_expt, convert="raw", transform="raw", filter_low=FALSE, norm="quant")
hpgl_quantile = exprs(quantile_expt$expressionset)
all.equal(cbcb_quantile, hpgl_quantile)
    
```

## log2cpm of the quantile normalization

```{r log2cpm_result}

cbcb_l2 = log2CPM(cbcb_quantile)
cbcb_l2cpm = cbcb_l2$y
hpgl_l2cpm_exprs = hpgl_norm(expt=pasilla_expt, transform="log2", norm="quant", convert="cpm", filter_low=FALSE)
hpgl_l2cpm = hpgl_l2cpm_exprs$counts
diff_df(cbcb_l2cpm, hpgl_l2cpm)

```

## some PCA plot checking

```{r pca_result}

cbcb_svd = cbcbSEQ::makeSVD(cbcb_l2cpm)
hpgl_pca_info = hpgl_pca(df=hpgl_l2cpm, design=pasilla_expt$design, colors=pasilla_expt$colors)
hpgl_svd = hpgl_pca_info$pca
diff_df(data.frame(cbcb_svd$v), data.frame(hpgl_svd$v))

cbcb_res = cbcbSEQ::pcRes(cbcb_svd$v, cbcb_svd$d, design$condition, design$libType)
hpgl_res = hpgl_pca_info$res
diff_df(cbcb_res, hpgl_res)

```

## ComBat invocation

```{r combat_result}

cbcb_batch = cbcbSEQ::combatMod(cbcb_l2cpm, batch=design$libType, mod=design$condition, noScale=TRUE)
hpgl_batch_expt = normalize_expt(expt=pasilla_expt, transform="log2", norm="quant", convert="cpm", batch="combatmod", filter_low=FALSE)
hpgl_batch = exprs(hpgl_batch_expt$expressionset)
diff_df(cbcb_batch, hpgl_batch)

```

## Voom invocation

```{r voom_result}

cbcb_libsize = cbcb_l2$lib.size
hpgl_libsize = quantile_expt$norm_libsize
cbcb_voom_ret = voomMod(cbcb_batch, model.matrix(~design$condition), lib.size=cbcb_libsize, plot=TRUE)
tmp_voom_ret = voomMod(hpgl_batch, model.matrix(~design$condition), lib.size=hpgl_libsize)
diff_df(cbcb_voom_ret$weights, tmp_voom_ret$weights)
hpgl_voom_ret = hpgl_voom(hpgl_batch, model.matrix(~design$condition), libsize=hpgl_libsize)
diff_df(cbcb_voom_ret$weights, hpgl_voom_ret$weights)
head(cbcb_voom_ret$weights)
head(tmp_voom_ret$weights)
head(hpgl_voom_ret$weights)

diff_df(cbcb_voom_ret$E, hpgl_voom_ret$E)
hpgl_voom_ret = hpgl_voom(hpgl_batch, model.matrix(~ 0 + design$condition), libsize=hpgl_libsize)
diff_df(cbcb_voom_ret$E, hpgl_voom_ret$E)
head(hpgl_voom_ret$weights)

```

## Limma invocation

```{r limma_result}

cbcb_fit = lmFit(cbcb_voom_ret)
cbcb_eb = eBayes(cbcb_fit)
cbcb_top = topTable(cbcb_eb, number=nrow(cbcb_eb))

hpgl_top = limma_pairwise(expt=hpgl_batch_expt, model_intercept=TRUE, model_batch=FALSE)

```


# quantile normalize: adjust counts for library size.
qcounts = qNorm(counts)
# convert counts to log2 counts per milliom. (voom scale)
cpm = log2CPM(qcounts)
names(cpm)
libsize = cpm$lib.size
cpm = cpm$y
#
# PCA analysis
# returns a list with two components v and d.
res = makeSVD(cpm)
pcRes(res$v,res$d, design$condition, design$libType)
plotPC(res$v,res$d, 
       col=design$condition, # color by batch
       pch=19, main="PCA plot",
       xlim=c(min(res$v[,1])-.08,max(res$v[,1])+.08),
       ylim=c(min(res$v[,2])-.08,max(res$v[,2])+.08))
text(res$v[,1], res$v[,2], design$libType, pos=1, cex=0.6)

tmp = combatMod(cpm, batch=design$libType, mod=design$condition, noScale=TRUE)
names(tmp)
# look at PCA results again
res = makeSVD(tmp)
# batch effect is reduced
pcRes(res$v,res$d, design$condition, design$libType)

plotPC(res$v,res$d, 
       col=design$condition, # color by batch
       pch=19, main="PCA plot",
       xlim=c(min(res$v[,1])-.08,max(res$v[,1])+.08),
       ylim=c(min(res$v[,2])-.08,max(res$v[,2])+.08))
text(res$v[,1], res$v[,2], design$libType, pos=1, cex=0.6) 



sel = top$adj.P.Val < 0.05
plot(top$logFC, -log10(top$adj.P.Val), pch=16, cex=0.3,
     main=paste(sum(sel), "/", length(sel)),col=ifelse(sel,"red","black"))
abline(v=c(-1,1), h=-log10(0.05), col="blue")

cond=design$condition
batch=design$libType
mod = model.matrix(~cond+batch, contrasts.arg=list(cond="contr.treatment", batch="contr.sum"))
v1 = voom(counts, mod) 
fit1 = lmFit(v1)
eb1 = eBayes(fit1)
top1 = topTable(eb1, coef=2, n=nrow(v1$E))
top1$ID = rownames(top1)

sel = top1$adj.P.Val < 0.05
plot(top1$logFC, -log10(top1$adj.P.Val), pch=16, cex=0.3,
     main=paste(sum(sel), "/", length(sel)),col=ifelse(sel,"red","black"))
abline(v=c(-1,1), h=-log10(0.05), col="blue")

tab = merge(top[,c("ID", "adj.P.Val")], top1[,c("ID", "adj.P.Val")], by="ID")
as.data.frame(table(combat = tab[,2] < 0.05, model = tab[,3] < 0.05))

```

## hpgltools attempt

```{r hpgltools}

library(hpgltools)
autoloads_all()



```

## Piece by piece comparison

```{r direct_compare}

raw = counts
qcounts = qNorm(counts)
# convert counts to log2 counts per milliom. (voom scale)
cpm = log2CPM(qcounts)
names(cpm)
libsize = cpm$lib.size
cpm = cpm$y

myraw = exprs(pasilla_expt$expressionset)
cor(raw, myraw)

myqcounts = hpgl_norm(expt=pasilla_expt, norm="quant", transform="raw", convert="raw", filter_low=FALSE)
myqcounts = myqcounts$counts
cor(qcounts, myqcounts)

l2 = log2(qcounts + 1)
myl2 = hpgl_norm(expt=pasilla_expt, norm="quant", transform="log2", filter_low=FALSE)
myl2 = myl2$counts
cor(l2, myl2)

l2cpm = log2CPM(qcounts)
l2cpm = l2cpm$y
myl2cpm = hpgl_norm(expt=pasilla_expt, norm="quant", transform="log2", convert="cbcbcpm", filter_low=FALSE)
myl2cpm = myl2cpm$counts
cor(l2cpm, myl2cpm) ## There is a small difference between log2CPM()'s cpm and edgeR's cpm()

myl2cpm_expt = normalize_expt(expt=pasilla_expt, norm="quant", transform="log2", convert="cpm", filter_low=FALSE)
myl2cpm_expt = exprs(myl2cpm_expt$expressionset)
cor(myl2cpm_expt, l2cpm)
cor(myl2cpm_expt, l2cpm, method="spearman")
myl2cpm_expt = normalize_expt(expt=pasilla_expt, norm="quant", transform="log2", convert="cbcbcpm", filter_low=FALSE)

res = makeSVD(l2cpm)
res_table = pcRes(res$v, res$d, design$condition, design$libType)
my_pca = hpgl_pca(expt=myl2cpm_expt, labels="normal")
another_res = makeSVD(myl2cpm)
cor(res$v, another_res$v, method="spearman")
cor(res$u, another_res$u)

head(res$v)
head(my_pca$pca$v)
cor(res$v, my_pca$pca$v)
head(res$u)
head(my_pca$pca$u)
cor(res$u, my_pca$pca$u)

myres_table = pcRes(my_pca$pca$v, my_pca$pca$d, design$condition, design$libType)

res_table
my_pca$res
cor(res_table, my_pca$res)

plotPC(res$v,res$d, 
       col=design$condition, # color by batch
       pch=19, main="PCA plot",
       xlim=c(min(res$v[,1])-.08,max(res$v[,1])+.08),
       ylim=c(min(res$v[,2])-.08,max(res$v[,2])+.08))
text(res$v[,1], res$v[,2], design$libType, pos=1, cex=0.6)
dev.new()
my_pca$plot

```
