#' Get a go term from ID
#'
#' @param id A go ID -- this may be a character or list(assuming the elements, not names, are goids)
#' 
#' @return Some text
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## text = goterm("GO:0032559")
goterm = function(go="GO:0032559") {
    go = as.character(go)
    term = function(id) {
        value = try(as.character(Term(GOTERM[id])), silent=TRUE)
        if (class(value) == "try-error") {
            value = "not found"
        }             
        return(value)
    }
    go = mapply(term, go)
    return(go)
    ## count = 1
    ## for (go in goid) {
    ##     value = try(as.character(Term(GOTERM[go])), silent=TRUE)
    ##     if (class(value) == "try-error") {
    ##         value = "not found"
    ##     }             
    ##    goid[count] = value
    ##     count = count + 1
    ## }
    ## return(goid)
}

#' Get a go synonym from an ID
#'
#' @param id A go ID -- this may be a character or list(assuming the elements, not names, are goids)
#' 
#' @return Some text
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## text = gosyn("GO:0032559")
gosyn = function(go) {
    go = as.character(go)
    syn = function(id) {
        value = try(as.character(Synonym(GOTERM[id])), silent=TRUE)
        if (class(value) == "try-error") {
            value = "not found"
        }             
        return(value)
    }
    go = mapply(syn, go)
    return(go)
}

#' Get a go secondary ID from an id
#'
#' @param id A go ID -- this may be a character or list(assuming the elements, not names, are goids)
#' 
#' @return Some text
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## text = gosec("GO:0032559")
gosec = function(go) {
    go = as.character(go)
    sec = function(id) {
        value = try(as.character(Secondary(GOTERM[id])), silent=TRUE)
        if (class(value) == "try-error") {
            value = "not found"
        }             
        return(value)
    }
    go = mapply(sec, go)
    return(go)
}

#' Get a go long-form definition from an id
#'
#' @param id A go ID -- this may be a character or list(assuming the elements, not names, are goids)
#' 
#' @return Some text
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## text = gosec("GO:0032559")
godef = function(go) {
    go = as.character(go)
    def = function(id) {
        value = try(as.character(Definition(GOTERM[id])), silent=TRUE)
        if (class(value) == "try-error") {
            value = "not found"
        }             
        return(value)
    }
    go = mapply(def, go)
    return(go)
}

#' Get a go ontology name from an ID
#'
#' @param id A go ID -- this may be a character or list(assuming the elements, not names, are goids)
#' 
#' @return Some text
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## text = gosec("GO:0032559")
goont = function(go) {
    go = as.character(go)
    ont = function(id) {
        value = try(as.character(Ontology(GOTERM[id])), silent=TRUE)
        if (class(value) == "try-error") {
            value = "not found"
        }             
        return(value)
    }
    go = mapply(ont, go)
    return(go)
}


#' Get a go level approximation from an ID
#'
#' @param id A go ID -- this may be a character or list(assuming the elements, not names, are goids)
#' 
#' @return Some text
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## text = gosec("GO:0032559")
golev = function(go) {
    go = as.character(go)
    level = 0
    go = "GO:0005874"
    while(class(try(as.character(Ontology(GOTERM[[go]])), silent=FALSE)) != 'try-error') {
        if (ontology == "MF") {
            ancestors = GOMFANCESTOR[[go]]
        } else if (ontology == "BP") {
            ancestors = GOBPANCESTOR[[go]]
        } else if (ontology == "CC") {
            ancestors = GOCCANCESTOR[[go]]
        } else {
            ## There was an error
            print(paste("There was an error getting the ontology: ", as.character(id), sep=""))
            ancestors = "error"
        }
        print("Incrementing level")
        go = ancestors[1]
        level = level + 1
    }  ## End while
    return(level)
}
golevel = function(go) {
    mapply(golev, go)
}

#' Test a GO id to see if it is useful by my arbitrary definition of 'useful'
#'
#' @param id A go ID -- this may be a character or list(assuming the elements, not names, are goids)
#' 
#' @return Some text
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## text = gosec("GO:0032559")
gotest = function(go) {
    go = as.character(go)
    tst = function(id) {
        value = GOTERM[[go]]
        if (is.null(value)) {
            return(0)
        } else {
            return(1)
        }
    }
    go = mapply(tst, go)
    return(go)
}

#' Make a table of gene ontology information
#'
#' @param df a dataframe of ontology information.  This is intended to
#' be the output from goseq including information like
#' numbers/category, GOids, etc.
#' @param file a csv file to which to write the table
#' 
#' @return the ontology table with annotation information included
#' @seealso \code{\link{GOTERM}}, \code{\link{GO.db}},
#' 
#' @export
#' @examples
#' ## annotated_go = goseq_table(go_ids)
goseq_table = function(df, file=NULL) {
    ## Testing args:
    ## df=godata
    ## end testing
    keep_columns = c("goid", "over_pval","under_pval","numDEinCat","numInCat", "qvalue")
    colnames(df) = keep_columns
    df$good = gotest(df$goid)
##    df$good = mapply(gotest, df$goid)
    df = subset(df, good == 1)
    df = df[, keep_columns]
    df$term = goterm(df$goid)
##    df$term = mapply(goterm, df$goid)
##    df$term = as.character(df$term)
    df = subset(df, !is.null(term))
    df$syn = gosyn(df$goid)
##    df$syn = mapply(gosyn, df$goid)
##    df$syn = as.character(df$syn)
    df$sec = goseq(df$goid)
##    df$sec = mapply(gosec, df$goid)
##    df$sec = as.character(df$sec)
    df$ont = goont(df$goid)
##    df$ont = mapply(goont, df$goid)
##    df$ont = as.character(df$ont)
    df = subset(df, !is.null(ont))
######    df$level = mapply(golevel, df$goid)
    df$def = godef(df$goid)
##    df$def = mapply(godef, df$goid)
##    df$def = as.character(df$def)
    if (!is.null(file)) {
        write.csv(df, file=file)
    }
    return(df)
}

#' Perform a simplified goseq analysis
#'
#' @param de_genes a data frame of differentially expressed genes, containing IDs and whatever other columns
#' @param lengths the length of each gene with an ID in de_genes
#' @param goids a list of ontology accessions to gene accessions
#' 
#' @return a big list including: the pwd:pwf function, alldata:the godata dataframe, pvalue_histogram:p-value histograms, godata_interesting:the ontology information of the enhanced groups, term_table:the goterms with some information about them, mf_subset:a plot of the MF enhanced groups, mfp_plot:the pvalues of the MF group, bp_subset:a plot of the BP enhanced groups, bpp_plot, cc_subset, and ccp_plot
#' @seealso \code{\link{goseq}} and \code{\link{clusterProfiler}}
#' @export
simple_goseq = function(de_genes, lengths=NULL, goids=NULL, adjust=0.1, pvalue=0.1, qvalue=0.1, method="Wallenius") {
    ## Test parameters
    ##de_genes = proeff_high
    ##lengths = gene_lengths
    ##goids = go_ids
    ##adjust = 0.1
    ##pvalue = 0.1
    ##qvalue=0.1
    ##method="Wallenius"
    ## End test parameters
    if (is.null(de_genes$ID)) {
        de_genes$ID = make.names(rownames(de_genes), unique=TRUE)
    }
    de_genes$DE = 1
    adjust=NULL
    de_table = de_genes[,c("ID","DE")]
    length_table = lengths[,c("ID","width")]
##    de_table = merge(de_table, length_table, by="ID")
    de_table = merge(de_table, length_table, by="ID", all.y=TRUE)    
    de_table[is.na(de_table)] = 0
    rownames(de_table) = make.names(de_table$ID, unique=TRUE)
    de_vector = as.vector(de_table$DE)
    names(de_vector) = rownames(de_table)
    width_vector = as.vector(length_table$width)
    names(width_vector) = length_table$ID
    pwf = nullp(DEgenes=de_vector, bias.data=width_vector, plot.fit=TRUE)
    pwf_plot = recordPlot()
##    godata = goseq(pwf, gene2cat=goids, method='Wallenius')
    colnames(goids) = c("ID", "GO")
    godata = goseq(pwf, gene2cat=goids, use_genes_without_cat=TRUE, method=method)
    goseq_p = my_histogram(godata$over_represented_pvalue, bins=20)
    print("Calculating q-values")
    qdata = godata$over_represented_pvalue
    qdata[qdata > 1] = 1 ## For scientific numbers which are 1.0000E+00 it might evaluate to 1.0000000000000001
    qdata = qvalue(qdata)
    godata = cbind(godata, qdata$qvalues)
    colnames(godata) = c("category","over_represented_pvalue","under_represented_pvalue","numDEInCat","numInCat","qvalue")
    print("Filling godata table with term information, this takes a while.")
    godata$ont = goont(godata$category)
    godata$term = goterm(godata$category)
    if (!is.null(adjust)) {
        godata_interesting = subset(godata, p.adjust(godata$over_represented_pvalue, method=method) < adjust)
        adjust_method=method
        if (dim(godata_interesting)[1] == 0) {
            print(paste("There are no genes with an adjusted pvalue < ", adjust, " using method: ", method, ".", sep=""))
            print(sprintf("Providing genes with an un-adjusted pvalue < %s", pvalue))
            godata_interesting = subset(godata, godata$over_represented_pvalue < pvalue)
            adjust_method="none"
        }
    } else {
        godata_interesting = subset(godata, godata$over_represented_pvalue < pvalue)
        adjust_method="none"
    }
    ##    goterms = goseq_table(godata_interesting)
    print("Making pvalue plots for the ontologies.")
    pvalue_plots = goseq_pval_plots(godata)
    mf_subset = subset(godata, ont == "MF")
    bp_subset = subset(godata, ont == "BP")
    cc_subset = subset(godata, ont == "CC")
    mf_interesting = subset(godata_interesting, ont == "MF")
    rownames(mf_interesting) = mf_interesting$category
    mf_interesting = mf_interesting[,c("ont","numDEInCat","numInCat","over_represented_pvalue","qvalue","term")]
    bp_interesting = subset(godata_interesting, ont == "BP")
    rownames(bp_interesting) = bp_interesting$category
    bp_interesting = bp_interesting[,c("ont","numDEInCat","numInCat","over_represented_pvalue","qvalue","term")]    
    cc_interesting = subset(godata_interesting, ont == "CC")
    cc_interesting = cc_interesting[,c("ont","numDEInCat","numInCat","over_represented_pvalue","qvalue","term")]    
    return_list = list(pwf=pwf, pwf_plot=pwf_plot,
        alldata=godata, pvalue_histogram=goseq_p,
        godata_interesting=godata_interesting,
        mf_interesting=mf_interesting, bp_interesting=bp_interesting, cc_interesting=cc_interesting,
        adjust_method=adjust_method,
        ##term_table=goterms,
        mf_subset=mf_subset, mfp_plot=pvalue_plots$mfp_plot,
        bp_subset=bp_subset, bpp_plot=pvalue_plots$bpp_plot,
        cc_subset=cc_subset, ccp_plot=pvalue_plots$ccp_plot,
        qdata=qdata)
    return(return_list)
}

#' Make a pvalue plot from topgo data
#'
#' @param topgo_data some data from topgo!
#' 
#' @return a plot!
#' @seealso \code{\link{goseq}}
#' @export
topgo_pval_plot = function(topgo, wrapped_width=20, cutoff=0.1, n=10) {
    ## Testing parameters
    ##topgo = rnarpf_topgo
    ##wrapped_width=20
    ##cutoff=0.1
    ##n=10
    ## End testing parameters
    mf_newdf = topgo$mf_table[,c("GO.ID", "Term", "Annotated","Significant","classic")]
    mf_newdf$score = mf_newdf$Significant / mf_newdf$Annotated
    mf_newdf$term = as.character(lapply(strwrap(mf_newdf$Term, wrapped_width, simplify=F), paste, collapse="\n"))
    mf_newdf$pvalue = as.numeric(mf_newdf$classic)
    mf_newdf = subset(mf_newdf, classic < cutoff)
    mf_newdf = mf_newdf[order(mf_newdf$pvalue, mf_newdf$score),]
    mf_newdf = mf_newdf[,c("GO.ID", "term", "pvalue", "score")]
    mf_newdf = head(mf_newdf, n=n)
    mf_pval_plot = pval_plot(mf_newdf, ontology="MF")
    bp_newdf = topgo$bp_table[,c("GO.ID", "Term", "Annotated","Significant","classic")]
    bp_newdf$score = bp_newdf$Significant / bp_newdf$Annotated
    bp_newdf$term = as.character(lapply(strwrap(bp_newdf$Term, wrapped_width, simplify=F), paste, collapse="\n"))
    bp_newdf$pvalue = as.numeric(bp_newdf$classic)
    bp_newdf = subset(bp_newdf, classic < cutoff)
    bp_newdf = bp_newdf[order(bp_newdf$classic, bp_newdf$score),]
    bp_newdf = head(bp_newdf, n=n)
    bp_newdf = bp_newdf[,c("GO.ID", "term", "pvalue", "score")]    
    bp_pval_plot = pval_plot(bp_newdf, ontology="MF")
    cc_newdf = topgo$cc_table[,c("GO.ID", "Term", "Annotated","Significant","classic")]
    cc_newdf$score = cc_newdf$Significant / cc_newdf$Annotated
    cc_newdf$term = as.character(lapply(strwrap(cc_newdf$Term, wrapped_width, simplify=F), paste, collapse="\n"))
    cc_newdf$pvalue = as.numeric(cc_newdf$classic)
    cc_newdf = subset(cc_newdf, classic < cutoff)
    cc_newdf = cc_newdf[order(cc_newdf$classic, cc_newdf$score),]
    cc_newdf = head(cc_newdf, n=n)
    cc_newdf = cc_newdf[,c("GO.ID", "term", "pvalue", "score")]        
    cc_pval_plot = pval_plot(cc_newdf, ontology="CC")
    pval_plots = list(MF=mf_pval_plot, BP=bp_pval_plot, CC=cc_pval_plot)
    return(pval_plots)
}

#' Make a pvalue plot from goseq data
#'
#' @param topgo_data some data from goseq!
#' 
#' @return a plot!
#' @seealso \code{\link{goseq}}
#' @export
goseq_pval_plots = function(goterms, wrapped_width=20, cutoff=0.1, n=10) {
    ## Testing parameters
    ##goterms = godata
    ##wrapped_width=20
    ##cutoff=0.1
    ##n=10
    ## End testing parameters
    plotting_mf = subset(goterms, complete.cases(goterms))
    plotting_mf$score = plotting_mf$numDEInCat / plotting_mf$numInCat    
    plotting_mf = subset(plotting_mf, ont == "MF")
    plotting_mf = subset(plotting_mf, term != "NULL")
    plotting_mf = subset(plotting_mf, over_represented_pvalue <= 0.1)
    plotting_mf = subset(plotting_mf, numInCat > 10)    
    plotting_mf = plotting_mf[order(plotting_mf$over_represented_pvalue),]
    plotting_mf = head(plotting_mf, n=n)
    plotting_mf = plotting_mf[,c("term","over_represented_pvalue","score")]
    colnames(plotting_mf) = c("term","pvalue","score")
    mf_pval_plot = pval_plot(plotting_mf, ontology="MF")

    plotting_bp = subset(goterms, complete.cases(goterms))
    plotting_bp$score = plotting_bp$numDEInCat / plotting_bp$numInCat
    plotting_bp = subset(plotting_bp, ont == "BP")
    plotting_bp = subset(plotting_bp, term != "NULL")
    plotting_bp = subset(plotting_bp, over_represented_pvalue <= 0.1)
    plotting_bp = subset(plotting_bp, numInCat > 10)    
    plotting_bp = plotting_bp[order(plotting_bp$over_represented_pvalue),]
    plotting_bp = head(plotting_bp, n=n)
    plotting_bp = plotting_bp[,c("term","over_represented_pvalue","score")]
    colnames(plotting_bp) = c("term","pvalue","score")
    bp_pval_plot = pval_plot(plotting_bp, ontology="BP")

    plotting_cc = subset(goterms, complete.cases(goterms))
    plotting_cc$score = plotting_cc$numDEInCat / plotting_cc$numInCat
    plotting_cc = subset(plotting_cc, ont == "CC")
    plotting_cc = subset(plotting_cc, term != "NULL")
    plotting_cc = subset(plotting_cc, over_represented_pvalue <= 0.1)
    plotting_cc = subset(plotting_cc, numInCat > 10)    
    plotting_cc = plotting_cc[order(plotting_cc$over_represented_pvalue),]
    plotting_cc = head(plotting_cc, n=n)
    plotting_cc = plotting_cc[,c("term","over_represented_pvalue","score")]
    colnames(plotting_cc) = c("term","pvalue","score")
    cc_pval_plot = pval_plot(plotting_cc, ontology="CC")
    
    pval_plots = list(mfp_plot=mf_pval_plot, bpp_plot=bp_pval_plot, ccp_plot=cc_pval_plot,
                      mf_subset=plotting_mf, bp_subset=plotting_bp, cc_subset=plotting_cc)
    return(pval_plots)    
}

#' Make a pvalue plot from a df of IDs, scores, and p-values
#'
#' @param df some data from topgo/goseq/clusterprofiler
#' 
#' @return a plot!
#' @seealso \code{\link{goseq}}
#' @export
pval_plot = function(df, ontology="MF") {
    y_name = paste("Enriched ", ontology, " categories.", sep="")
    pvalue_plot = ggplot(df, aes(term, score)) +
        geom_bar(stat="identity") +
        coord_flip() +
        scale_x_discrete(name=y_name) +
        aes(fill=pvalue) +
        scale_fill_continuous(low="red", high="blue") +
        theme(text=element_text(size=10))
    return(pvalue_plot)
}

#' Perform a simplified topgo analysis
#'
#' @param de_genes a data frame of differentially expressed genes, containing IDs and whatever other columns
#' @param goid_map a file containing mappings of genes to goids in the format expected by topgo
#' 
#' @return a big list including the various outputs from topgo
#' @export
simple_topgo = function(de_genes, goids="reference/go/id2go.map", fisherlimit=0.1, signodes=100, sigforall=TRUE, numchar=300) {
    ## Test parameters
    ##de_genes = proeff_low
    ##numchar=300
    ##goids = "reference/go/id2go.map"
    ##fisherlimit=0.1
    ##sigforall = TRUE
    ## End test parameters
    ## Some neat ideas from the topGO documentation:
### geneList <- getPvalues(exprs(eset), classlabel = y, alternative = "greater")
### topDiffGenes <- function(allScore) {
### return(allScore < 0.01)
###}
### A variant of these operations make it possible to give topGO scores so that
### a larger array of tests may be performed
### x <- topDiffGenes(geneList)
### sum(x) ## the number of selected genes
### If we do something like above to give scores to all the 'DEgenes', then we set up the GOdata object like this:
### mf_GOdata = new("topGOdata", description="something", ontology="BP", allGenes = entire_geneList, geneSel=topDiffGenes, annot=annFUN.gene2GO, gene2GO=geneID2GO, nodeSize=2)
    geneID2GO = readMappings(file=goids)
    annotated_genes = names(geneID2GO)
    interesting_genes = factor(as.integer(annotated_genes %in% de_genes$ID))
    names(interesting_genes) = annotated_genes
    mf_GOdata = new("topGOdata", ontology="MF", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    bp_GOdata = new("topGOdata", ontology="BP", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    cc_GOdata = new("topGOdata", ontology="CC", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    test_stat = new("classicCount", testStatistic=GOFisherTest, name="Fisher test")
    mf_fisher_result = getSigGroups(mf_GOdata, test_stat)
    bp_fisher_result = getSigGroups(bp_GOdata, test_stat)
    cc_fisher_result = getSigGroups(cc_GOdata, test_stat)
    test_stat = new("classicScore", testStatistic=GOKSTest, name="KS tests")
    mf_ks_result = getSigGroups(mf_GOdata, test_stat)
    bp_ks_result = getSigGroups(bp_GOdata, test_stat)
    cc_ks_result = getSigGroups(cc_GOdata, test_stat)
    test_stat = new("elimScore", testStatistic=GOKSTest, name="Fisher test", cutOff=0.01)
    mf_el_result = getSigGroups(mf_GOdata, test_stat)
    bp_el_result = getSigGroups(bp_GOdata, test_stat)
    cc_el_result = getSigGroups(cc_GOdata, test_stat)
    test_stat = new("weightCount", testStatistic=GOFisherTest, name="Fisher test", sigRatio="ratio")
    mf_weight_result = getSigGroups(mf_GOdata, test_stat)
    bp_weight_result = getSigGroups(bp_GOdata, test_stat)
    cc_weight_result = getSigGroups(cc_GOdata, test_stat)

    mf_siglist = names(which(mf_fisher_result@score <= fisherlimit))
    mf_topnodes = length(mf_siglist)
    mf_allRes = try(GenTable(mf_GOdata, classic=mf_fisher_result, KS=mf_ks_result, EL=mf_el_result, weight=mf_weight_result, orderBy="classic", ranksOf="classic", topNodes=mf_topnodes, numChar=numchar))
    mf_qvalues = as.data.frame(qvalue(topGO::score(mf_fisher_result))$qvalues)
    mf_allRes = merge(mf_allRes, mf_qvalues, by.x="GO.ID", by.y="row.names")
    mf_allRes$classic = as.numeric(mf_allRes$classic)
    mf_allRes = mf_allRes[with(mf_allRes, order(classic)), ]    
    colnames(mf_allRes) = c("GO.ID","Term","Annotated","Significant","Expected","classic","KS","EL","weight","qvalue")
    
    bp_siglist = names(which(bp_fisher_result@score <= fisherlimit))
    bp_topnodes = length(bp_siglist)
    ##    bp_allRes = try(GenTable(bp_GOdata, classic=bp_fisher_result, KS=bp_ks_result, EL=bp_el_result, weight=bp_weight_result, orderBy="classic", ranksOf="classic", topNodes=bp_topnodes, numChar=numchar))
    bp_allRes = try(GenTable(bp_GOdata, classic=bp_fisher_result, KS=bp_ks_result, EL=bp_el_result, weight=bp_weight_result, orderBy="classic", ranksOf="classic", topNodes=bp_topnodes, numChar=numchar))    
    bp_qvalues = as.data.frame(qvalue(topGO::score(bp_fisher_result))$qvalues)
    bp_allRes = merge(bp_allRes, bp_qvalues, by.x="GO.ID", by.y="row.names", all.x=TRUE)
    bp_allRes$classic = as.numeric(bp_allRes$classic)
    bp_allRes = bp_allRes[with(bp_allRes, order(classic)), ]
    colnames(bp_allRes) = c("GO.ID","Term","Annotated","Significant","Expected","classic","KS","EL","weight","qvalue")    

    cc_siglist = names(which(cc_fisher_result@score <= fisherlimit))
    cc_topnodes = length(cc_siglist)
    cc_allRes = try(GenTable(cc_GOdata, classic=cc_fisher_result, KS=cc_ks_result, EL=cc_el_result, weight=cc_weight_result, orderBy="classic", ranksOf="classic", topNodes=cc_topnodes, numChar=numchar))
    cc_qvalues = as.data.frame(qvalue(topGO::score(cc_fisher_result))$qvalues)
    cc_allRes = merge(cc_allRes, cc_qvalues, by.x="GO.ID", by.y="row.names")
    cc_allRes$classic = as.numeric(cc_allRes$classic)
    cc_allRes = cc_allRes[with(cc_allRes, order(classic)), ]    
    colnames(cc_allRes) = c("GO.ID","Term","Annotated","Significant","Expected","classic","KS","EL","weight","qvalue")        

    mf_interesting = subset(mf_allRes, classic <= fisherlimit)
    rownames(mf_interesting) = NULL
    mf_interesting$ont = "MF"
    mf_interesting = mf_interesting[,c("GO.ID","ont","Annotated","Significant","Expected","classic","qvalue","KS","EL","weight","Term")]
    
    bp_interesting = subset(bp_allRes, classic <= fisherlimit)
    rownames(bp_interesting) = NULL
    bp_interesting$ont = "BP"
    bp_interesting = bp_interesting[,c("GO.ID","ont","Annotated","Significant","Expected","classic","qvalue","KS","EL","weight","Term")]
    
    cc_interesting = subset(cc_allRes, classic <= fisherlimit)
    rownames(cc_interesting) = NULL
    cc_interesting$ont = "CC"
    cc_interesting = cc_interesting[,c("GO.ID","ont","Annotated","Significant","Expected","classic","qvalue","KS","EL","weight","Term")]

    mf_first_group = mf_allRes[1, "GO.ID"]
    mf_first_density = myGroupDensity(mf_GOdata, mf_first_group, ranks=TRUE)
    
    information = list(
        mf_siglist=mf_siglist, bp_siglist=bp_siglist, cc_siglist=cc_siglist,
        mf_godata=mf_GOdata, bp_godata=bp_GOdata, cc_godata=cc_GOdata,
        mf_fisher=mf_fisher_result, bp_fisher=bp_fisher_result, cc_fisher=cc_fisher_result,
        mf_ks=mf_ks_result, bp_ks=bp_ks_result, cc_ks=cc_ks_result,
        mf_el=mf_el_result, bp_el=bp_el_result, cc_el=cc_el_result,
        mf_weight=mf_weight_result, bp_weight=bp_weight_result, cc_weight=cc_weight_result,
        mf_table=mf_allRes, bp_table=bp_allRes, cc_table=cc_allRes,
        mf_interesting=mf_interesting, bp_interesting=bp_interesting, cc_interesting=cc_interesting)
    return(information)
}

#' Print trees from topgo
#'
#' @param de_genes a data frame of differentially expressed genes, containing IDs and whatever other columns
#' @param goid_map a file containing mappings of genes to goids in the format expected by topgo
#' 
#' @return a big list including the various outputs from topgo
#' @export
topgo_trees = function(tg, score_limit=0.01, sigforall=TRUE, do_mf_fisher_tree=TRUE, do_bp_fisher_tree=TRUE, do_cc_fisher_tree=TRUE, do_mf_ks_tree=FALSE, do_bp_ks_tree=FALSE, do_cc_ks_tree=FALSE, do_mf_el_tree=FALSE, do_bp_el_tree=FALSE, do_cc_el_tree=FALSE, do_mf_weight_tree=FALSE, do_bp_weight_tree=FALSE, do_cc_weight_tree=FALSE) {
    ## Testing parameters
    ##tg = proeff_high_top
    ##sigforall=TRUE
    ##score_limit = 0.01
    ## End testing parameters
    mf_fisher_nodes = mf_fisher_tree = NULL
    if (do_mf_fisher_tree) {
        included = length(which(topGO::score(tg$mf_fisher) <= score_limit))
        mf_fisher_nodes = try(showSigOfNodes(tg$mf_godata, topGO::score(tg$mf_fisher), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(mf_fisher_nodes)[1] != 'try-error') {
            mf_fisher_tree = try(recordPlot())
        }
    }
    bp_fisher_nodes = bp_fisher_tree = NULL
    if (do_bp_fisher_tree) {
        included = length(which(topGO::score(tg$bp_fisher) <= score_limit))
        bp_fisher_nodes = try(showSigOfNodes(tg$bp_godata, topGO::score(tg$bp_fisher), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(bp_fisher_nodes)[1] != 'try-error') {
            bp_fisher_tree = try(recordPlot())
        }
    }
    cc_fisher_nodes = cc_fisher_tree = NULL
    if (do_cc_fisher_tree) {
        included = length(which(topGO::score(tg$cc_fisher) <= score_limit))        
        cc_fisher_nodes = try(showSigOfNodes(tg$cc_godata, topGO::score(tg$cc_fisher), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(cc_fisher_nodes)[1] != 'try-error') {
            cc_fisher_tree = try(recordPlot())
        }
    }
    mf_ks_nodes = mf_ks_tree = NULL
    if (do_mf_ks_tree) {
        included = length(which(topGO::score(tg$mf_ks) <= score_limit))        
        mf_ks_nodes = try(showSigOfNodes(tg$mf_godata, topGO::score(tg$mf_ks), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(mf_ks_nodes)[1] != 'try-error') {
            mf_ks_tree = try(recordPlot())
        }
    }
    bp_ks_nodes = bp_ks_tree = NULL
    if (do_bp_ks_tree) {
        included = length(which(topGO::score(tg$bp_ks) <= score_limit))
        bp_ks_nodes = try(showSigOfNodes(tg$bp_godata, topGO::score(tg$bp_ks), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(bp_ks_nodes)[1] != 'try-error') {
            bp_ks_tree = try(recordPlot())
        }
    }
    cc_ks_nodes = cc_ks_tree = NULL
    if (do_cc_ks_tree) {
        included = length(which(topGO::score(tg$cc_ks) <= score_limit))        
        cc_ks_nodes = try(showSigOfNodes(tg$cc_godata, topGO::score(tg$cc_ks), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(cc_ks_nodes)[1] != 'try-error') {
            cc_ks_tree = try(recordPlot())
        }
    }
    mf_el_nodes = mf_el_tree = NULL
    if (do_mf_el_tree) {
        included = length(which(topGO::score(tg$mf_el) <= score_limit))        
        mf_el_nodes = try(showSigOfNodes(tg$mf_godata, topGO::score(tg$mf_el), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(mf_el_nodes)[1] != 'try-error') {
            mf_el_tree = try(recordPlot())
        }
    }
    bp_el_nodes = bp_el_tree = NULL
    if (do_bp_el_tree) {
        included = length(which(topGO::score(tg$bp_el) <= score_limit))                
        bp_el_nodes = try(showSigOfNodes(tg$bp_godata, topGO::score(tg$bp_el), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(bp_el_nodes)[1] != 'try-error') {
            bp_el_tree = try(recordPlot())
        }
    }
    cc_el_nodes = cc_el_tree = NULL
    if (do_cc_el_tree) {
        included = length(which(topGO::score(tg$cc_el) <= score_limit))                
        cc_el_nodes = try(showSigOfNodes(tg$cc_godata, topGO::score(tg$cc_el), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(cc_el_nodes)[1] != 'try-error') {
            cc_el_tree = try(recordPlot())
        }
    }
    mf_weight_nodes = mf_weight_tree = NULL
    if (do_mf_weight_tree) {
        included = length(which(topGO::score(tg$mf_weight) <= score_limit))                
        mf_weight_nodes = try(showSigOfNodes(tg$mf_godata, topGO::score(tg$mf_weight), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(mf_weight_nodes)[1] != 'try-error') {
            mf_weight_tree = try(recordPlot())
        }
    }
    bp_weight_nodes = bp_weight_tree = NULL
    if (do_bp_weight_tree) {
        included = length(which(topGO::score(tg$bp_weight) <= score_limit))                
        bp_weight_nodes = try(showSigOfNodes(tg$bp_godata, topGO::score(tg$bp_weight), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(bp_weight_nodes)[1] != 'try-error') {
            bp_weight_tree = try(recordPlot())
        }
    }
    cc_weight_nodes = cc_weight_tree = NULL
    if (do_cc_weight_tree) {
        included = length(which(topGO::score(tg$cc_weight) <= score_limit))                
        cc_weight_nodes = try(showSigOfNodes(tg$cc_godata, topGO::score(tg$cc_weight), useInfo="all", sigForAll=sigforall, firstSigNodes=included, useFullNames=TRUE, plotFunction=myGOplot))
        if (class(cc_weight_nodes)[1] != 'try-error') {
            cc_weight_tree = try(recordPlot())
        }
    }
    
    trees = list(
        mf_fisher_nodes=mf_fisher_nodes, bp_fisher_nodes=bp_fisher_nodes, cc_fisher_nodes=cc_fisher_nodes,
        mf_ks_nodes=mf_ks_nodes, bp_ks_nodes=bp_ks_nodes, cc_ks_nodes=cc_ks_nodes,
        mf_el_nodes=mf_el_nodes, bp_el_nodes=bp_el_nodes, cc_el_nodes=cc_el_nodes,
        mf_weight_nodes=mf_weight_nodes, bp_weight_nodes=bp_weight_nodes, cc_weight_nodes=cc_weight_nodes,
        mf_fisher_tree=mf_fisher_tree, bp_fisher_tree=bp_fisher_tree, cc_fisher_tree=cc_fisher_tree,
        mf_ks_tree=mf_ks_tree, bp_ks_tree=bp_ks_tree, cc_ks_tree=cc_ks_tree,
        mf_el_tree=mf_el_tree, bp_el_tree=bp_el_tree, cc_el_tree=cc_el_tree,
        mf_weight_tree=mf_weight_tree, bp_weight_tree=bp_weight_tree, cc_weight_tree=cc_weight_tree)
    return(trees)
}

#' Perform a simplified clusterProfiler analysis
#'
#' @param de_genes a data frame of differentially expressed genes, containing IDs and whatever other columns
#' @param goids a file containing mappings of genes to goids in the format expected by topgo
#' @param golevel a relative level in the tree for printing p-value plots, higher is more specific
#' @param pcutoff a p-value cutoff
#' @param qcutoff a q-value cutoff
#' @param padjust a method for adjusting the p-values
#' @param fold_changes a df of fold changes for the DE genes
#' @param include_cnetplots the cnetplots are often stupid and can be left behind
#' @param showcategory how many categories to show in p-value plots
#' 
#' @return a big list including the various outputs from topgo
#' @export
simple_clusterprofiler = function(de_genes, goids=NULL, golevel=4, pcutoff=0.1,
    qcutoff=1.0, fold_changes=NULL, include_cnetplots=TRUE,
    showcategory=12, universe=NULL, organism="lm",
    wrapped_width=20, method="Walllenius", padjust="BH") {
    ## Test parameters
    ##de_genes = proeff_high
    ##de_genes = proeff_high
    ##goids=go_ids
    ##fold_changes=NULL
    ##organism = "lm"
    ##method = "Wallenius"
    ##adjust=0.1
    ##pcutoff=0.1
    ##qcutoff=1.0
    ##golevel=4
    ##wrapped_width = 20
    ##showcategory=12
    ##padjust="BH"
    ##universe = rownames(rnarpf_pro_table)
    ## End test parameters
    gene_list = as.character(de_genes$ID)
    gomapping_test = try(load("GO2EG.rda"))
    if (class(gomapping_test) == 'try-error') {
        print("Generating GO mapping data for cluster profiler from the goids data.")
        gomap = goids
        colnames(gomap) = c("entrezgene", "go_accession")
        buildGOmap(gomap)
    } else {
        print("Using GO mapping data located in GO2EG.rda")
    }

    print("Testing gseGO")
    ego2 = try(gseGO(geneList=gene_list, organism=organism, ont="GO", nPerm=100, minGSSize=2, pvalueCutoff=1, verbose=TRUE))
    print(ego2)
    print("Starting MF(molecular function) analysis")
    mf_group = groupGO(gene_list, organism=organism, ont="MF", level=golevel, readable=TRUE)
    mf_all = my_enrichGO(gene_list, organism=organism, ont="MF", pvalueCutoff=1.0, qvalueCutoff=1.0, pAdjustMethod="none")
    all_mf_phist = my_histogram(mf_all@result$pvalue, bins=50)
    enriched_mf = my_enrichGO(gene_list, organism=organism, ont="MF", pvalueCutoff=pcutoff, qvalueCutoff=qcutoff, pAdjustMethod=padjust)
    
    print("Starting BP(biological process) analysis")
    bp_group = groupGO(gene_list, organism=organism, ont="BP", level=golevel, readable=TRUE)
    bp_all = my_enrichGO(gene_list, organism=organism, ont="BP", pvalueCutoff=1.0, qvalueCutoff=1.0, pAdjustMethod="none")
    all_bp_phist = my_histogram(bp_all@result$pvalue, bins=50)
    enriched_bp = my_enrichGO(gene_list, organism=organism, ont="BP", pvalueCutoff=pcutoff, qvalueCutoff=qcutoff, pAdjustMethod=padjust)

    print("Starting CC(cellular component) analysis")
    cc_group = groupGO(gene_list, organism=organism, ont="CC", level=golevel, readable=TRUE)
    cc_all = my_enrichGO(gene_list, organism=organism, ont="CC", pvalueCutoff=1.0, qvalueCutoff=1.0, pAdjustMethod="none")
    enriched_cc = my_enrichGO(gene_list, organism=organism, ont="CC", pvalueCutoff=pcutoff, qvalueCutoff=qcutoff, pAdjustMethod=padjust)
    all_cc_phist = my_histogram(cc_all@result$pvalue, bins=50)

    mf_group_barplot = try(barplot(mf_group, drop=TRUE, showCategory=showcategory), silent=TRUE)
    if (class(mf_group_barplot)[1] != 'try-error') {
        mf_group_barplot$data$Description = as.character(lapply(strwrap(mf_group_barplot$data$Description, wrapped_width, simplify=F),paste,collapse="\n"))
    }
    
    bp_group_barplot = try(barplot(bp_group, drop=TRUE, showCategory=showcategory), silent=TRUE)
    if (class(bp_group_barplot)[1] != 'try-error') {
        bp_group_barplot$data$Description = as.character(lapply(strwrap(bp_group_barplot$data$Description, wrapped_width, simplify=F),paste,collapse="\n"))
    }
    
    cc_group_barplot = try(barplot(cc_group, drop=TRUE, showCategory=showcategory), silent=TRUE)
    if (class(cc_group_barplot)[1] != 'try-error') {
        cc_group_barplot$data$Description = as.character(lapply(strwrap(cc_group_barplot$data$Description, wrapped_width, simplify=F),paste,collapse="\n"))
    }

    enriched_mf_barplot = try(barplot(enriched_mf, categorySize="pvalue", showCategory=showcategory), silent=TRUE)
    if (class(enriched_mf_barplot)[1] != 'try-error') {
        enriched_mf_barplot$data$Description = as.character(lapply(strwrap(enriched_mf_barplot$data$Description, wrapped_width, simplify=F),paste,collapse="\n"))
    }
    all_mf_barplot = try(barplot(all_mf, categorySize="pvalue", showCategory=showcategory), silent=TRUE)
    if (class(all_mf_barplot)[1] != 'try-error') {
        all_mf_barplot$data$Description = as.character(lapply(strwrap(all_mf_barplot$data$Description, wrapped_width, simplify=F),paste,collapse="\n"))
    }
        
    enriched_bp_barplot = try(barplot(enriched_bp, categorySize="pvalue", showCategory=showcategory), silent=TRUE)
    if (class(enriched_bp_barplot)[1] != 'try-error') {
        enriched_bp_barplot$data$Description = as.character(lapply(strwrap(enriched_bp_barplot$data$Description, wrapped_width, simplify=F),paste,collapse="\n"))
    }
    
    enriched_cc_barplot = try(barplot(enriched_cc, categorySize="pvalue", showCategory=showcategory), silent=TRUE)
    if (class(enriched_cc_barplot)[1] != 'try-error') {
        enriched_cc_barplot$data$Description = as.character(lapply(strwrap(enriched_cc_barplot$data$Description, wrapped_width, simplify=F),paste,collapse="\n"))
    }
    
    if (include_cnetplots == TRUE) {
        print("Attempting to include the cnetplots from clusterProfiler.")
        print("They fail often, if this is causing errors, set:")
        print("include_cnetplots to FALSE")
        cnetplot_mf = try(cnetplot(enriched_mf, categorySize="pvalue", foldChange=fold_changes))
        if (class(cnetplot_mf)[1] != 'try-error') {
            cnetplot_mf = recordPlot()
        }
        cnetplot_bp = try(cnetplot(enriched_bp, categorySize="pvalue", foldChange=fold_changes))
        if (class(cnetplot_bp)[1] != 'try-error') {
            cnetplot_bp = recordPlot()
        }
        cnetplot_cc = try(cnetplot(enriched_cc, categorySize="pvalue", foldChange=fold_changes))
        if (class(cnetplot_cc)[1] != 'try-error') {
            cnetplot_cc = recordPlot()
        }
    }
    mf_interesting = mf_all@result
    rownames(mf_interesting) = NULL
    mf_interesting$ont = "MF"
    mf_interesting = mf_interesting[,c("ID","ont","GeneRatio","BgRatio","pvalue","p.adjust","qvalue","geneID","Count","Description")]    
    mf_interesting = subset(mf_interesting, pvalue <= 0.1)

    bp_interesting = bp_all@result
    rownames(bp_interesting) = NULL
    bp_interesting$ont = "BP"
    bp_interesting = bp_interesting[,c("ID","ont","GeneRatio","BgRatio","pvalue","p.adjust","qvalue","geneID","Count","Description")]    
    bp_interesting = subset(bp_interesting, pvalue <= 0.1)

    cc_interesting = cc_all@result
    rownames(cc_interesting) = NULL
    cc_interesting$ont = "CC"
    cc_interesting = cc_interesting[,c("ID","ont","GeneRatio","BgRatio","pvalue","p.adjust","qvalue","geneID","Count","Description")]
    cc_interesting = subset(cc_interesting, pvalue <= 0.1)
    
    return_information = list(
        mf_interesting=mf_interesting, bp_interesting=bp_interesting, cc_interesting=cc_interesting,
        mf_pvals=all_mf_phist, bp_pvals=all_bp_phist, cc_pvals=all_cc_phist,        
        mf_enriched=enriched_mf, bp_enriched=enriched_bp, cc_enriched=enriched_cc,
        mf_all=mf_all, bp_all=bp_all, cc_all=cc_all,
        mf_enriched_barplot=enriched_mf_barplot, bp_enriched_barplot=enriched_bp_barplot, cc_enriched_barplot=enriched_cc_barplot,
        mf_cnetplot=cnetplot_mf, bp_cnetplot=cnetplot_bp, cc_cnetplot=cnetplot_cc,
        mf_group=mf_group, bp_group=bp_group, cc_group=cc_group,
        mf_group_barplot=mf_group_barplot, bp_group_barplot=bp_group_barplot, cc_group_barplot=cc_group_barplot)
    return(return_information)        
}

#' Make fun trees a la topgo from goseq data.
#'
#' @param de_genes some differentially expressed genes
#' @param godata data from goseq
#' @param goids a mapping of IDs to GO in the Ramigo expected format
#' @param sigforall Print significance on all nodes?
#' 
#' @return a plot!
#' @seealso \code{\link{Ramigo}}
#' @export
goseq_trees = function(de_genes, godata, goids="reference/go/id2go.map", score_limit=0.01) {
    ## Testing parameters
    ##de_genes = proeff_high
    ##godata = proeff_high_go
    ##goids = "reference/go/id2go.map"
    ##score_limit=0.01
    ## End parameters
    enriched_categories = godata$alldata$category
    geneID2GO = readMappings(file=goids)
    annotated_genes = names(geneID2GO)
    interesting_genes = factor(as.integer(annotated_genes %in% de_genes$ID))
    names(interesting_genes) = annotated_genes
    mf_GOdata = new("topGOdata", ontology="MF", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    bp_GOdata = new("topGOdata", ontology="BP", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    cc_GOdata = new("topGOdata", ontology="CC", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    mf_enriched_ids = godata$alldata$category
    mf_enriched_scores = godata$alldata$over_represented_pvalue
    names(mf_enriched_scores) = mf_enriched_ids
    mf_avail_nodes = as.list(mf_GOdata@graph@nodes)
    names(mf_avail_nodes) = mf_GOdata@graph@nodes
    mf_nodes = mf_enriched_scores[names(mf_enriched_scores) %in% names(mf_avail_nodes)]
    mf_included = length(which(mf_nodes <= score_limit))
    mf_tree_data = try(showSigOfNodes(mf_GOdata, mf_nodes, useInfo="all", sigForAll=TRUE, firstSigNodes=mf_included, useFullNames=TRUE, plotFunction=myGOplot))
    if (class(mf_tree_data) == 'try-error') {
        print("There was an error generating the MF tree.")
        mf_tree = NULL
    } else {
        mf_tree = recordPlot()
    }    
    bp_enriched_ids = godata$alldata$category
    bp_enriched_scores = godata$alldata$over_represented_pvalue
    names(bp_enriched_scores) = bp_enriched_ids
    bp_avail_nodes = as.list(bp_GOdata@graph@nodes)
    names(bp_avail_nodes) = bp_GOdata@graph@nodes
    bp_nodes = bp_enriched_scores[names(bp_enriched_scores) %in% names(bp_avail_nodes)]
    bp_included = length(which(bp_nodes <= score_limit))
    bp_tree_data = try(showSigOfNodes(bp_GOdata, bp_nodes, useInfo="all", sigForAll=TRUE, firstSigNodes=bp_included, useFullNames=TRUE, plotFunction=myGOplot))
    if (class(bp_tree_data) == 'try-error') {
        print("There was an error generating the BP tree.")
        bp_tree = NULL
    } else {
        bp_tree = recordPlot()
    }    
    cc_enriched_ids = godata$alldata$category
    cc_enriched_scores = godata$alldata$over_represented_pvalue
    names(cc_enriched_scores) = cc_enriched_ids
    cc_avail_nodes = as.list(cc_GOdata@graph@nodes)
    names(cc_avail_nodes) = cc_GOdata@graph@nodes
    cc_nodes = cc_enriched_scores[names(cc_enriched_scores) %in% names(cc_avail_nodes)]
    cc_included = length(which(cc_nodes <= score_limit))
    cc_tree_data = try(showSigOfNodes(cc_GOdata, cc_nodes, useInfo="all", sigForAll=TRUE, firstSigNodes=cc_included, useFullNames=TRUE, plotFunction=myGOplot))
    if (class(cc_tree_data) == 'try-error') {
        print("There was an error generating the CC tree.")
        cc_tree = NULL
    } else {
        cc_tree = recordPlot()
    }
    trees = list(MF=mf_tree, BP=bp_tree, CC=cc_tree, MFdata=mf_tree_data, BPdata=bp_tree_data, CCdata=cc_tree_data)
    return(trees)
}

## Take clusterprofile group data and print it on a tree as topGO does
#' Make fun trees a la topgo from goseq data.
#'
#' @param de_genes some differentially expressed genes
#' @param godata data from cluster Profiler
#' @param goids a mapping of IDs to GO in the Ramigo expected format
#' @param sigforall Print significance on all nodes?
#' 
#' @return a plot!
#' @seealso \code{\link{Ramigo}}
#' @export
cluster_trees = function(de_genes, cpdata, goids="reference/go/id2go.map", score_limit=0.1) {
    ## Testing parameters
    ##de_genes = proeff_high
    ##cpdata = proeff_high_cl
    ##goids = "reference/go/id2go.map"
    ##score_limit=0.1
    ## End testing parameters
    mf_all = cpdata$mf_all
    mf_enriched = cpdata$mf_enriched
    bp_all = cpdata$bp_all
    bp_enriched = cpdata$bp_enriched
    cc_all = cpdata$cc_all
    cc_enriched = cpdata$cc_enriched
    geneID2GO = readMappings(file=goids)
    annotated_genes = names(geneID2GO)
    interesting_genes = factor(as.integer(annotated_genes %in% de_genes$ID))
    names(interesting_genes) = annotated_genes
    mf_GOdata = new("topGOdata", ontology="MF", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    bp_GOdata = new("topGOdata", ontology="BP", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    cc_GOdata = new("topGOdata", ontology="CC", allGenes=interesting_genes, annot=annFUN.gene2GO, gene2GO=geneID2GO)
    mf_all_ids = mf_all@result$ID
    bp_all_ids = bp_all@result$ID
    cc_all_ids = cc_all@result$ID
    mf_all_scores = mf_all@result$p.adjust
    bp_all_scores = bp_all@result$p.adjust
    cc_all_scores = cc_all@result$p.adjust
    names(mf_all_scores) = mf_all_ids
    names(bp_all_scores) = bp_all_ids
    names(cc_all_scores) = cc_all_ids
    mf_included = length(which(mf_all_scores <= score_limit))
    mf_tree_data = try(showSigOfNodes(mf_GOdata, mf_all_scores, useInfo="all", sigForAll=TRUE, firstSigNodes=mf_included, useFullNames=TRUE, plotFunction=myGOplot))
    if (class(mf_tree_data)[1] == 'try-error') {
        mf_tree = NULL
    } else {
        mf_tree = recordPlot()
    }
    bp_included = length(which(bp_all_scores <= score_limit))
    bp_tree_data = try(showSigOfNodes(bp_GOdata, bp_all_scores, useInfo="all", sigForAll=TRUE, firstSigNodes=bp_included, useFullNames=TRUE, plotFunction=myGOplot))
    if (class(bp_tree_data)[1] == 'try-error') {
        bp_tree = NULL
    } else {
        bp_tree = recordPlot()
    }
    cc_included = length(which(cc_all_scores <= score_limit))
    cc_tree_data = try(showSigOfNodes(cc_GOdata, cc_all_scores, useInfo="all", sigForAll=TRUE, firstSigNodes=cc_included, useFullNames=TRUE, plotFunction=myGOplot))
    if (class(cc_tree_data)[1] == 'try-error') {
        cc_tree = NULL
    } else {
        cc_tree = recordPlot()
    }
    trees = list(MF=mf_tree, BP=bp_tree, CC=cc_tree, MFdata=mf_tree_data, BPdata=bp_tree_data, CCdata=cc_tree_data)
    return(trees)
}

#' Print some data onto KEGG pathways
#'
#' @param de_genes some differentially expressed genes
#' @param godata data from cluster Profiler
#' @param goids a mapping of IDs to GO in the Ramigo expected format
#' @param sigforall Print significance on all nodes?
#' 
#' @return a plot!
#' @seealso \code{\link{Ramigo}}
#' @export
my_pathview = function(fold_changes, pathway="03008", species="lma") {
    all_pathways = unique(keggLink("pathway", "lma"))
    paths = all_pathways
    paths = gsub("path:", "", paths)
    load("RData")
    all_modules = unique(keggLink("module","lma"))
    setwd("pathview")
    head(merged_data)
    path_data = merged_data

    lma_names = function(datum) {
        tmp = merged_data
        tmp$names = rownames(merged_data)
        tmp$names = gsub("LmjF", "LMJF", tmp$names)
        tmp$names = gsub("\\.","_", tmp$names)
        names(datum) = tmp$names
        rm(tmp)
        return(datum)
    }

    path_datum = path_data$prometa_eff
    path_datum = lma_names(path_datum)

    for (count in 1:length(paths)) {
        path = paths[count]
        limits=c(min(path_datum, na.rm=TRUE), max(path_datum, na.rm=TRUE))
        pv = try(pathview(gene.data=path_datum, pathway.id=path, species="lma", limit=list(gene=limits, cpd=limits), map.null=TRUE, gene.idtype="KEGG", split.group=TRUE, expand.node=TRUE, kegg.native=TRUE, map.symbol=TRUE, same.layer=FALSE, res=1200, new.signature=FALSE, cex=0.05, key.pos="topright"))
    }
}

#' A minor hack in the clusterProfiler function 'enrichGO'
#'
#' @param gene some differentially expressed genes
#' @param organism by default 'human'
#' @param ont by default 'MF'
#' 
#' @return some clusterProfiler data
#' @seealso \code{\link{clusterProfiler}}
#' @export
my_enrichGO = function(gene, organism="human", ont="MF",
    pvalueCutoff=0.05, pAdjustMethod="BH", universe,
    qvalueCutoff=0.2, minGSSize=2, readable=FALSE) {
    ## Testing parameters
    ##gene=gene_list
    ##organism="lm"
    ##ont="BP"
    ##minGSSize=2
    ## End testing parameters
    information = my_enrich.internal(gene, organism=organism, pvalueCutoff=pvalueCutoff,
##        pAdjustMethod=pAdjustMethod, ont=ont, universe=universe,
        pAdjustMethod=pAdjustMethod, ont=ont,
        qvalueCutoff=qvalueCutoff, minGSSize=minGSSize)
##    print(summary(information))
    return(information)
}

#' A minor hack in the clusterProfiler function 'enrich.internal'
#'
#' @param gene some differentially expressed genes
#' @param organism by default 'human'
#' @param ont by default 'MF'
#' 
#' @return some clusterProfiler data
#' @seealso \code{\link{clusterProfiler}}
#' @export
my_enrich.internal = function(gene, organism, pvalueCutoff=1, pAdjustMethod="BH",
    ont, minGSSize=2, qvalueCutoff=0.2, readable=FALSE, universe=NULL) {
    ## I removed universe as an argument
    ##gene = gene_list
    ##minGSSize=2
    ##ont="BP"
    ##pAdjustMethod="BH"
    ##pvalueCutoff=1
    ##qvalueCutoff=1
    ###
    gene <- as.character(gene)
    class(gene) <- ont
    qExtID2TermID = EXTID2TERMID(gene, organism)
    qTermID <- unlist(qExtID2TermID)
    if (is.null(qTermID)) {
        return(NA)
    }
    ## Term ID -- query external ID association list.
    qExtID2TermID.df <- data.frame(extID=rep(names(qExtID2TermID),
                                   times=lapply(qExtID2TermID, length)),
                                   termID=qTermID)
    qExtID2TermID.df <- unique(qExtID2TermID.df)
    termID <- NULL ## to satisfy code tools
    qTermID2ExtID <- dlply(qExtID2TermID.df, .(termID),
                           .fun=function(i) as.character(i$extID))
    class(organism) <- ont
    extID <- ALLEXTID(organism)
    if(!missing(universe)) {
        extID <- intersect(extID, universe)
    }
    qTermID2ExtID <- sapply(qTermID2ExtID, intersect, extID)
### The L.major ontologies are smaller, and so if the default (5)
### minGSSize is left in place, this comes up as null and therefore
### ends with the entire thing returning null.  I changed it to 2 for
### the moment.
    idx <- sapply(qTermID2ExtID, length) > minGSSize
    if (sum(idx) == 0) {
        return (NULL)
    }
    qTermID2ExtID <- qTermID2ExtID[idx]
    ## Term ID annotate query external ID
    qTermID <- unique(names(qTermID2ExtID))
    ## prepare parameter for hypergeometric test
    k <- sapply(qTermID2ExtID, length)
    k <- k[qTermID]
    class(qTermID) <- ont
    termID2ExtID <- TERMID2EXTID(qTermID, organism)
    termID2ExtID <- sapply(termID2ExtID, intersect, extID)
    if (length(qTermID)== 1) {
        M <- nrow(termID2ExtID)
    } else {
        M <- sapply(termID2ExtID, length) 
        M <- M[qTermID]
    }
    N <- rep(length(extID), length(M))
    ## n <- rep(length(gene), length(M)) ## those genes that have no annotation should drop.
    n <- rep(length(qExtID2TermID), length(M))
    args.df <- data.frame(numWdrawn=k-1, ## White balls drawn
                          numW=M,        ## White balls
                          numB=N-M,      ## Black balls
                          numDrawn=n)    ## balls drawn
    ## calcute pvalues based on hypergeometric model
    pvalues <- apply(args.df, 1, function(n)
                     phyper(n[1], n[2], n[3], n[4], lower.tail=FALSE)
                     )
    ## gene ratio and background ratio
    GeneRatio <- apply(data.frame(a=k, b=n), 1, function(x)
                       paste(x[1], "/", x[2], sep="", collapse="")
                       )
    BgRatio <- apply(data.frame(a=M, b=N), 1, function(x)
                     paste(x[1], "/", x[2], sep="", collapse="")
                     )
    Over <- data.frame(ID=as.character(qTermID),
                       GeneRatio=GeneRatio,
                       BgRatio=BgRatio,
                       pvalue=pvalues)
    original_over = Over
    p.adj <- p.adjust(Over$pvalue, method=pAdjustMethod)
    cat(sprintf("The minimum observed adjusted pvalue is: %f\n", min(p.adj)))
    qobj = try(qvalue(p=Over$pvalue, lambda=0.05, pi0.method="bootstrap"), silent=TRUE)
    if (class(qobj) == "qvalue") {
        qvalues <- qobj$qvalues
    } else {
        qvalues <- NA
    }
    geneID <- sapply(qTermID2ExtID, function(i) paste(i, collapse="/"))
    geneID <- geneID[qTermID]
    Over <- data.frame(Over,
                       p.adjust = p.adj,
                       qvalue=qvalues,
                       geneID=geneID,
                       Count=k)
    class(qTermID) <- ont
    Description <- TERM2NAME(qTermID, organism)

    if (length(qTermID) != length(Description)) {
        idx <- qTermID %in% names(tt)
        Over <- Over[idx,] 
    }
    Over$Description <- Description
    nc <- ncol(Over)
    Over <- Over[, c(1,nc, 2:(nc-1))]
    Over <- Over[order(pvalues),]
    Over <- Over[ Over$pvalue <= pvalueCutoff, ]
    Over <- Over[ Over$p.adjust <= pvalueCutoff, ]
    if (! any(is.na(Over$qvalue))) {
        Over <- Over[ Over$qvalue <= qvalueCutoff, ]
    }
    Over$ID <- as.character(Over$ID)
    Over$Description <- as.character(Over$Description)
    category <- as.character(Over$ID)
    ### On my computer this fails.
    ##    rownames(Over) <- category
    x <- new("enrichResult",
             result = Over,
             pvalueCutoff=pvalueCutoff,
             pAdjustMethod=pAdjustMethod,
             organism=as.character(organism),
             ontology=as.character(ont),
             gene=as.character(gene),
             geneInCategory=qTermID2ExtID[category]
             )
    if(readable) {
        x <- setReadable(x)
    }
    return (x)
}


## this function will plot the GO DAG or parts of it
## sigNodes:     a named vector of terms p-values, the names are the GO terms
## wantedNodes:  the nodes that we want to find, we will plot this nodes with
##               a different color. The vector contains the names pf the nodes
## oldSigNodes:  used to plot the (new) sigNodes in the same collor range
##               as the old ones
## export.to.dot.file: is a global variable given the name of the output .dot file

#' @export
getEdgeWeights <- function (graph) {  
  weightsList <- edgeWeights(graph)
  to <- lapply(weightsList, names)
  from <- nodes(graph)

  if (any(is.na(unlist(to))) || any(is.na(from))) 
    stop("Edge names do not match node names.")

  edge.names <- paste(rep(from, listLen(to)), unlist(to), sep = "~")
  edge.weights <- unlist(weightsList)
  names(edge.weights) <- edge.names

  return(edge.weights)
}


#' A minor hack in the topGO GOplot function
#'
#' @export
myGOplot <- function(dag, sigNodes, dag.name = 'GO terms', edgeTypes = T,
                   nodeShape.type = c('box', 'circle', 'ellipse', 'plaintext')[3],
                   genNodes = NULL, wantedNodes = NULL, showEdges = T, useFullNames = T,
                   oldSigNodes = NULL, nodeInfo=nodeInfo) {
    
  if(!missing(sigNodes))
    sigNodeInd = TRUE
  else
    sigNodeInd = FALSE
  
  ## we set the global Graphviz attributes
  ##  graphAttrs <- getDefaultAttrs(layoutType = 'dot')
  graphAttrs <- getDefaultAttrs(layoutType = 'dot')  
  graphAttrs$cluster <- NULL
  graphAttrs$edge$arrowsize = "0.4"
  graphAttrs$edge$weight = "0.01"

  ##graphAttrs$graph$splines <- FALSE
  graphAttrs$graph$size = "12.0,12.0"
  graphAttrs$graph$margin = "0.0,0.0"
##  graphAttrs$graph$ranksep = "0.02"
##  graphAttrs$graph$nodesep = "0.30"  
  
  ## set the node shape
  graphAttrs$node$shape <- nodeShape.type
  ##graphAttrs$node$fixedsize <- FALSE
  ## set the fontsize for the nodes labels
  graphAttrs$node$fontsize <- '20.0'
  graphAttrs$node$height <- '2.0'
  graphAttrs$node$width <- '3.0'
  graphAttrs$graph$size = "12,12"
  graphAttrs$node$color = "lightblue"
  graphAttrs$node$fontname = "arial"
  graphAttrs$node$style = "invis"    

  ## set the local attributes lists
  nodeAttrs <- list()
  edgeAttrs <- list()

  ## try to use adaptive node size
  #nodeAttrs$fixedsize[nodes(dag)] <- rep(FALSE, numNodes(dag))
  
  if(is.null(nodeInfo)) {
    nodeInfo <- character(numNodes(dag))
    names(nodeInfo) <- nodes(dag)
  }
  else
    nodeInfo <- paste('\\\n', nodeInfo, sep = '')
  
  ## a good idea is to use xxxxxxx instead of GO:xxxxxxx as node labes
  node.names <- nodes(dag)
  if(!useFullNames)
    nodeAttrs$label <- sapply(node.names,
                              function(x) {
                                return(paste(substr(x, 4, nchar(node.names[1])),
                                             nodeInfo[x], sep = ''))
                              })
  else {
    nodeAttrs$label <- paste(node.names, nodeInfo, sep = '')
    names(nodeAttrs$label) <- node.names
  }

  ## we will change the shape and the color of the nodes that generated the dag
  if(!is.null(wantedNodes)) {
    diffNodes <- setdiff(wantedNodes, genNodes)
    if(length(diffNodes) > 0) {
      nodeAttrs$color[diffNodes] <- rep('lightblue', .ln <- length(diffNodes))
      nodeAttrs$shape[diffNodes] <- rep('circle', .ln)
      nodeAttrs$height[diffNodes] <- rep('0.45', .ln)
      ##nodeAttrs$width[diffNodes] <- rep('0.6', .ln)
      ##nodeAttrs$fixedsize[wantedNodes] <- rep(TRUE, .ln)
    }
  }

  ## we will change the shape and the color of the nodes we want back
  if(!is.null(genNodes)) {
    nodeAttrs$color[genNodes] <- rep('lightblue', .ln <- length(genNodes))
    nodeAttrs$shape[genNodes] <- rep('box', .ln)
    #nodeAttrs$fixedsize[genNodes] <- rep(FALSE, .ln)    
  }
  
  ## we will use different fillcolors for the nodes
  if(sigNodeInd) {
    if(!is.null(oldSigNodes)) {
      old.logSigNodes <- log10(sort(oldSigNodes[nodes(dag)]))
      old.range <- range(old.logSigNodes)
      logSigNodes <- log10(sort(sigNodes))
      logSigNodes[logSigNodes < old.range[1]] <- old.range[1]
      logSigNodes[logSigNodes > old.range[2]] <- old.range[2]

      ## debug:  old.range == range(logSigNodes)
      #if(!identical(all.equal(old.range, range(logSigNodes)), TRUE)){
      #  print(old.range)
      #  print(range(logSigNodes))
      #  stop('some stupid error here :)')
      #}
    }
    else
      old.logSigNodes <- logSigNodes <- log10(sort(sigNodes))
    
    
    sigColor <- round(logSigNodes - range(logSigNodes)[1] + 1)
    old.sigColor <- round(old.logSigNodes - range(old.logSigNodes)[1] + 1)


    mm <- max(sigColor, old.sigColor)
    sigColor <- sigColor + (mm - max(sigColor))

    colorMap <- heat.colors(mm)
    nodeAttrs$fillcolor <- unlist(lapply(sigColor, function(x) return(colorMap[x])))
  }
  
  if(!showEdges)
    graphAttrs$edge$color <- 'white'
  else
    ## if we want to differentiate between 'part-of' and 'is-a' edges
    if(edgeTypes)
      ##    0 for a is_a relation,  1 for a part_of relation
        ##edgeAttrs$color <- ifelse(getEdgeWeights(dag) == 0, 'black', 'red')
        edgeAttrs$color <- ifelse(getEdgeWeights(dag) == 0, 'black', 'black')
  

  ##plot(dag, attrs = graphAttrs, nodeAttrs = nodeAttrs, edgeAttrs = edgeAttrs)

  return(agopen(graph = dag, name = dag.name, attrs = graphAttrs,
                nodeAttrs = nodeAttrs,  edgeAttrs = edgeAttrs))
}


GOplot.orig <- function(dag, sigNodes, dag.name = 'GO terms', edgeTypes = T,
                   nodeShape.type = c('box', 'circle', 'ellipse', 'plaintext')[3],
                   genNodes = NULL, wantedNodes = NULL, showEdges = T, useFullNames = F,
                   oldSigNodes = NULL, nodeInfo = NULL) {
    
  if(!missing(sigNodes))
    sigNodeInd = TRUE
  else
    sigNodeInd = FALSE
  
  ## we set the global Graphviz attributes
  graphAttrs <- getDefaultAttrs(layoutType = 'dot')
  graphAttrs$cluster <- NULL

  #graphAttrs$graph$splines <- FALSE
  
  ## set the node shape
  graphAttrs$node$shape <- nodeShape.type

  ## set the fontsize for the nodes labels
  graphAttrs$node$fontsize <- '14'
  #graphAttrs$node$height <- '1.0'
  #graphAttrs$node$width <- '1.5'

  ## set the local attributes lists
  nodeAttrs <- list()
  edgeAttrs <- list()

  ## try to use adaptive node size
  #nodeAttrs$fixedsize[nodes(dag)] <- rep(FALSE, numNodes(dag))
  
  if(is.null(nodeInfo)) {
    nodeInfo <- character(numNodes(dag))
    names(nodeInfo) <- nodes(dag)
  }
  else
    nodeInfo <- paste('\\\n', nodeInfo, sep = '')
  
  ## a good idea is to use xxxxxxx instead of GO:xxxxxxx as node labes
  node.names <- nodes(dag)
  if(!useFullNames)
    nodeAttrs$label <- sapply(node.names,
                              function(x) {
                                return(paste(substr(x, 4, nchar(node.names[1])),
                                             nodeInfo[x], sep = ''))
                              })
  else {
    nodeAttrs$label <- paste(node.names, nodeInfo, sep = '')
    names(nodeAttrs$label) <- node.names
  }

  ## we will change the shape and the color of the nodes that generated the dag
  if(!is.null(wantedNodes)) {
    diffNodes <- setdiff(wantedNodes, genNodes)
    if(length(diffNodes) > 0) {
      nodeAttrs$color[diffNodes] <- rep('lightblue', .ln <- length(diffNodes))
      nodeAttrs$shape[diffNodes] <- rep('circle', .ln)
      nodeAttrs$height[diffNodes] <- rep('0.45', .ln)
      ##nodeAttrs$width[diffNodes] <- rep('0.6', .ln)
      ##nodeAttrs$fixedsize[wantedNodes] <- rep(TRUE, .ln)
    }
  }

  ## we will change the shape and the color of the nodes we want back
  if(!is.null(genNodes)) {
    nodeAttrs$color[genNodes] <- rep('lightblue', .ln <- length(genNodes))
    nodeAttrs$shape[genNodes] <- rep('box', .ln)
    #nodeAttrs$fixedsize[genNodes] <- rep(FALSE, .ln)    
  }
  
  ## we will use different fillcolors for the nodes
  if(sigNodeInd) {
    if(!is.null(oldSigNodes)) {
      old.logSigNodes <- log10(sort(oldSigNodes[nodes(dag)]))
      old.range <- range(old.logSigNodes)
      logSigNodes <- log10(sort(sigNodes))
      logSigNodes[logSigNodes < old.range[1]] <- old.range[1]
      logSigNodes[logSigNodes > old.range[2]] <- old.range[2]

      ## debug:  old.range == range(logSigNodes)
      #if(!identical(all.equal(old.range, range(logSigNodes)), TRUE)){
      #  print(old.range)
      #  print(range(logSigNodes))
      #  stop('some stupid error here :)')
      #}
    }
    else
      old.logSigNodes <- logSigNodes <- log10(sort(sigNodes))
    
    
    sigColor <- round(logSigNodes - range(logSigNodes)[1] + 1)
    old.sigColor <- round(old.logSigNodes - range(old.logSigNodes)[1] + 1)


    mm <- max(sigColor, old.sigColor)
    sigColor <- sigColor + (mm - max(sigColor))

    colorMap <- heat.colors(mm)
    nodeAttrs$fillcolor <- unlist(lapply(sigColor, function(x) return(colorMap[x])))
  }
  
  if(!showEdges)
    graphAttrs$edge$color <- 'white'
  else
    ## if we want to differentiate between 'part-of' and 'is-a' edges
    if(edgeTypes)
      ##    0 for a is_a relation,  1 for a part_of relation
      ## edgeAttrs$color <- ifelse(getEdgeWeights(dag) == 0, 'black', 'red')
      edgeAttrs$color <- ifelse(getEdgeWeights(dag) == 0, 'black', 'black')
  

  ##plot(dag, attrs = graphAttrs, nodeAttrs = nodeAttrs, edgeAttrs = edgeAttrs)

  return(agopen(graph = dag, name = dag.name, attrs = graphAttrs,
                nodeAttrs = nodeAttrs,  edgeAttrs = edgeAttrs))
}


myGroupDensity = function(object, whichGO, ranks=TRUE, rm.one=FALSE) {
    ## Testing parameters
    ##object = mf_GOdata
    ##whichGO = mf_first_group
    ## End testing parameters
    groupMembers <- genesInTerm(object, whichGO)[[1]]
    allS <- geneScore(object, use.names = TRUE)
    if(rm.one) {
        allS <- allS[allS < 0.99]
    }
    xlab <- "Gene' score"
    if(ranks) {
        allS <- rank(allS, ties.method = "random")
        xlab <- "Gene's rank" 
    }
    group <- as.integer(names(allS) %in% groupMembers)
    xx <- data.frame(score=allS, group = factor(group, labels=paste(c("complementary", whichGO), "  (", table(group), ")", sep="")))
    plot = densityplot( ~ score | group, data=xx, layout=c(1,2), xlab=xlab)
    return(plot)
}
